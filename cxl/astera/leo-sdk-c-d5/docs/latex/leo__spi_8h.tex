\hypertarget{leo__spi_8h}{}\doxysection{leo-\/sdk-\/c/include/leo\+\_\+spi.h File Reference}
\label{leo__spi_8h}\index{leo-\/sdk-\/c/include/leo\_spi.h@{leo-\/sdk-\/c/include/leo\_spi.h}}


Definition of SPI types for the SDK.  


{\ttfamily \#include \char`\"{}DW\+\_\+apb\+\_\+ssi.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}leo\+\_\+api\+\_\+types.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}leo\+\_\+error.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}leo\+\_\+globals.\+h\char`\"{}}\newline
{\ttfamily \#include $<$stdbool.\+h$>$}\newline
{\ttfamily \#include $<$stdint.\+h$>$}\newline
{\ttfamily \#include $<$stdio.\+h$>$}\newline
Include dependency graph for leo\+\_\+spi.\+h\+:
% FIG 0
This graph shows which files directly or indirectly include this file\+:
% FIG 1
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structblock__info}{block\+\_\+info}}
\item 
struct \mbox{\hyperlink{structtoc__code__data}{toc\+\_\+code\+\_\+data}}
\item 
struct \mbox{\hyperlink{structtoc__syscfg__data}{toc\+\_\+syscfg\+\_\+data}}
\item 
struct \mbox{\hyperlink{structtoc__config}{toc\+\_\+config}}
\item 
struct \mbox{\hyperlink{structtoc__data}{toc\+\_\+data}}
\item 
struct \mbox{\hyperlink{structLeoSpiDescriptionEntryType}{Leo\+Spi\+Description\+Entry\+Type}}
\item 
struct \mbox{\hyperlink{structLeoSpiDescriptionBlockDataType}{Leo\+Spi\+Description\+Block\+Data\+Type}}
\item 
struct \mbox{\hyperlink{structflash__boot__load__ctrl__info__t}{flash\+\_\+boot\+\_\+load\+\_\+ctrl\+\_\+info\+\_\+t}}
\end{DoxyCompactItemize}
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{leo__spi_8h_a654e4d43534f3335ac1cb9b694ff204b}\label{leo__spi_8h_a654e4d43534f3335ac1cb9b694ff204b}} 
\#define {\bfseries SPI\+\_\+\+FLASH\+\_\+\+SIZE}~(8 $\ast$ 1024 $\ast$ 1024)
\item 
\mbox{\Hypertarget{leo__spi_8h_af5b9727caca176f18a4de8bc8293533d}\label{leo__spi_8h_af5b9727caca176f18a4de8bc8293533d}} 
\#define {\bfseries LEO\+\_\+\+SPI\+\_\+\+FLASH\+\_\+\+HEADER\+\_\+\+BYTE\+\_\+\+CNT}~(0x24)
\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{leo__spi_8h_a3d0728e92b0ba4b0f63f81de4f0e5e93}\label{leo__spi_8h_a3d0728e92b0ba4b0f63f81de4f0e5e93}} 
typedef struct \mbox{\hyperlink{structblock__info}{block\+\_\+info}} {\bfseries block\+\_\+info\+\_\+t}
\item 
\mbox{\Hypertarget{leo__spi_8h_a87d41b0f5f19c45da19d89e7314e4df4}\label{leo__spi_8h_a87d41b0f5f19c45da19d89e7314e4df4}} 
typedef struct \mbox{\hyperlink{structtoc__code__data}{toc\+\_\+code\+\_\+data}} {\bfseries toc\+\_\+code\+\_\+data\+\_\+t}
\item 
\mbox{\Hypertarget{leo__spi_8h_a8890b5cb62d25e0b4126ff698e4a265c}\label{leo__spi_8h_a8890b5cb62d25e0b4126ff698e4a265c}} 
typedef struct \mbox{\hyperlink{structtoc__syscfg__data}{toc\+\_\+syscfg\+\_\+data}} {\bfseries toc\+\_\+syscfg\+\_\+data\+\_\+t}
\item 
\mbox{\Hypertarget{leo__spi_8h_abb30e0384fc0a25913163340627364b5}\label{leo__spi_8h_abb30e0384fc0a25913163340627364b5}} 
typedef struct \mbox{\hyperlink{structtoc__config}{toc\+\_\+config}} {\bfseries toc\+\_\+config\+\_\+t}
\item 
\mbox{\Hypertarget{leo__spi_8h_a2f2613ac1579ad1fca176f093d750b9a}\label{leo__spi_8h_a2f2613ac1579ad1fca176f093d750b9a}} 
typedef struct \mbox{\hyperlink{structtoc__data}{toc\+\_\+data}} {\bfseries toc\+\_\+data\+\_\+t}
\end{DoxyCompactItemize}
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{leo__spi_8h_aeb99945dbdc5420f239332d41b4b75f7}\label{leo__spi_8h_aeb99945dbdc5420f239332d41b4b75f7}} 
enum {\bfseries BLOCKTYPE} \{ \newline
{\bfseries BT\+\_\+\+MAIN\+\_\+e} = 0x01
, {\bfseries BT\+\_\+\+SYSTEM\+\_\+\+CONFIG\+\_\+e} = 0x04
, {\bfseries BT\+\_\+\+PERSISTENT\+\_\+\+DATA\+\_\+e} = 0x06
, {\bfseries BT\+\_\+\+DESCRIPTION\+\_\+e} = 0x07
, \newline
{\bfseries BT\+\_\+\+TOC\+\_\+e} = 0x86
, {\bfseries BT\+\_\+\+FLASH\+\_\+\+CTRL\+\_\+e} = 0x87
, {\bfseries BT\+\_\+\+FLASH\+\_\+\+RSVD\+\_\+e} = 0xdd
, {\bfseries BT\+\_\+\+END\+\_\+e} = 0xff
 \}
\item 
\mbox{\Hypertarget{leo__spi_8h_a26c0312ac66c00f31cf886616c48afa2}\label{leo__spi_8h_a26c0312ac66c00f31cf886616c48afa2}} 
enum \{ {\bfseries SPI\+\_\+\+DEVICE\+\_\+\+SST26\+WF064\+C\+\_\+e}
, {\bfseries SPI\+\_\+\+DEVICE\+\_\+\+MX25\+U6432\+\_\+e}
, {\bfseries SPI\+\_\+\+DEVICE\+\_\+\+EOL\+\_\+e}
 \}
\item 
\mbox{\Hypertarget{leo__spi_8h_aecd12a18eeb0ee701fc7b0efd5068266}\label{leo__spi_8h_aecd12a18eeb0ee701fc7b0efd5068266}} 
enum \{ \newline
{\bfseries FLASH\+\_\+\+BOOT\+\_\+\+LOAD\+\_\+\+STATUS\+\_\+\+OK} = 0
, {\bfseries FLASH\+\_\+\+BOOT\+\_\+\+LOAD\+\_\+\+READ\+\_\+\+DW\+\_\+\+STATUS\+\_\+\+NO\+\_\+\+CMD\+\_\+\+ACTIVE} = 0x0001
, {\bfseries FLASH\+\_\+\+BOOT\+\_\+\+LOAD\+\_\+\+DW\+\_\+\+STATUS\+\_\+\+TX\+\_\+\+FIFO\+\_\+\+OVERFLOW} = 0x0002
, {\bfseries FLASH\+\_\+\+BOOT\+\_\+\+LOAD\+\_\+\+DW\+\_\+\+STATUS\+\_\+\+RX\+\_\+\+FIFO\+\_\+\+UNDERFLOW} = 0x0004
, \newline
{\bfseries FLASH\+\_\+\+BOOT\+\_\+\+LOAD\+\_\+\+READ\+\_\+\+DW\+\_\+\+STATUS\+\_\+\+RX\+\_\+\+FIFO\+\_\+\+OVERFLOW} = 0x0008
, {\bfseries FLASH\+\_\+\+BOOT\+\_\+\+LOAD\+\_\+\+ERROR\+\_\+\+TIMEOUT} = 0x0010
, {\bfseries FLASH\+\_\+\+BOOT\+\_\+\+LOAD\+\_\+\+ERROR\+\_\+\+STILL\+\_\+\+BUSY} = 0x0020
, {\bfseries FLASH\+\_\+\+BOOT\+\_\+\+LOAD\+\_\+\+ERROR\+\_\+\+ADDR\+\_\+\+MIS\+\_\+\+MATCH} = 0x0040
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{leo__spi_8h_a86419b4256b0bf5e099fa746cbcf8e8d}{astera\+SPISetup}} (\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}} product)
\begin{DoxyCompactList}\small\item\em Low-\/level SPI Initialization and setup. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. This function has to be called before any other SPI function. Initialize and Open the SPI driver, setup the clocks, Pin signals, baud rate, and other SPI parameters. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_ae7dca44511b92f3a219d53c4e9685d70}{astera\+SPIClose}} (\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}} product)
\begin{DoxyCompactList}\small\item\em Low-\/level SPI Initialization and setup. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. This function is called to close the SPI device. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{leo__spi_8h_aca1bcd1e189d052c6918f54dffa01059}\label{leo__spi_8h_aca1bcd1e189d052c6918f54dffa01059}} 
void {\bfseries astera\+SPIReset} (\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}} product)
\item 
void \mbox{\hyperlink{leo__spi_8h_aaa3bb1a48505737c84aaf11bb2ec23ed}{astera\+SPIChip\+Bulk\+Erase}} (\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}} product)
\begin{DoxyCompactList}\small\item\em Low-\/level SPI API to completely bulk erase the flash chip THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. This function erases the entire flash chip. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_a9ca9f0deb9da8eae88efb1be873f4c6b}{astera\+SPIBlock\+Erase}} (\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}} product, uint32\+\_\+t block\+\_\+addr, uint32\+\_\+t block\+\_\+count)
\begin{DoxyCompactList}\small\item\em Low-\/level block erase SPI function. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. This function erases one or more blocks of memory specified by the address. \end{DoxyCompactList}\item 
unsigned char \mbox{\hyperlink{leo__spi_8h_a047259b839e2dafc169d995997311c1c}{astera\+SPIRead}} (\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}} product, uint32\+\_\+t addr)
\begin{DoxyCompactList}\small\item\em Low-\/level SPI Read. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. reads one byte from the SPI bus at the address specified. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_a38bd047aed25ead22942d189cbde06df}{astera\+SPIRead\+Block}} (\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}} product, uint32\+\_\+t addr, uint8\+\_\+t $\ast$data, uint32\+\_\+t len)
\begin{DoxyCompactList}\small\item\em Low-\/level SPI Read Block. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. reads a block of bytes into the given array from the SPI bus at the address specified. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_a8e393dac017a7638b0762d5a9bdd7300}{astera\+SPIRead\+Page}} (\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}} product, uint32\+\_\+t addr, uint8\+\_\+t $\ast$data, uint32\+\_\+t len)
\begin{DoxyCompactList}\small\item\em Low-\/level SPI Read Page. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. Reads the number of pages desired from SPI bus at the address specified. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_a7edff1078270d42f03e8a236fa39e18c}{astera\+SPIWrite}} (\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}} product, uint32\+\_\+t addr, uint8\+\_\+t $\ast$data, uint32\+\_\+t len)
\begin{DoxyCompactList}\small\item\em Low-\/level SPI Write. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. writes a sequence of bytes to the SPI bus at the address specified the flash cells are not autmatically erased, it is important to clear the flash cells by calling the erase function before writing to the flash. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_a6f8ccdac75eb92fd6b347a5fc8418726}{astera\+SPIWrite\+Block}} (\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}} product, uint32\+\_\+t addr, uint8\+\_\+t $\ast$data, uint32\+\_\+t len)
\begin{DoxyCompactList}\small\item\em Low-\/level SPI Write Block. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. writes a block of bytes to the SPI bus at the address specified. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_ab791f034fc71dd22cd28bd7976e2d441}{astera\+SPIWrite\+Page}} (\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}} product, uint32\+\_\+t addr, uint8\+\_\+t $\ast$data, uint32\+\_\+t len)
\begin{DoxyCompactList}\small\item\em Low-\/level SPI Write Page. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. Writes the number of pages desired to the SPI bus at the address specified. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_a8af0705d1a24d00713885b205c5d6840}{leo\+Spi\+Init}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver)
\begin{DoxyCompactList}\small\item\em Low-\/level code to initialize the DW APB. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_a5235ae236a0f3ddd6938092e548429d6}{dw\+\_\+apb\+\_\+ssi\+\_\+\+SSIENR}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver, uint32\+\_\+t enable)
\begin{DoxyCompactList}\small\item\em low-\/level code to enable/disable the DW APB SSI \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_abf7b785d49d9ec872c4e155ef6fb38b3}{dw\+\_\+apb\+\_\+ssi\+\_\+\+SER}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver, uint32\+\_\+t enable)
\begin{DoxyCompactList}\small\item\em low-\/level code to select/not select slave device by using the Slave Enable Register in DW APB SSI Valid only when DW APB SSI is configured as a master device. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_a9295236392c024299336aea54004513c}{dw\+\_\+apb\+\_\+ssi\+\_\+\+CTRLR0}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver, uint32\+\_\+t CTRLR0\+\_\+val)
\begin{DoxyCompactList}\small\item\em low-\/level code to control the serial data transfer Cannot write into this register while DW APB SSI is enabled Valid only when DW APB SSI is configured as a master device. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_a9a312f0a56397e468f5c7dfecfafcdca}{dw\+\_\+apb\+\_\+ssi\+\_\+\+CTRLR1}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver, uint32\+\_\+t CTRLR1\+\_\+val)
\begin{DoxyCompactList}\small\item\em low-\/level code to control the end of serial data transfers when in Rx mode. Cannot write into this register while DW APB SSI is enabled Valid only when DW APB SSI is configured as a master device. The DW\+\_\+apb\+\_\+ssi continues to rx serial data until the number of data frames received is equal to this register value plus 1. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_a86be803c04c299a120984588c3f1687d}{dw\+\_\+apb\+\_\+ssi\+\_\+\+RXFLR}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver, uint32\+\_\+t $\ast$value)
\begin{DoxyCompactList}\small\item\em low-\/level code to check Rx FIFO level register read the register to get the number of valid data entries in the Rx FIFO memory. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_acdc9617db34e6fad7f78da066eb4632b}{dw\+\_\+apb\+\_\+ssi\+\_\+\+TXFLR}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver, uint32\+\_\+t $\ast$value)
\begin{DoxyCompactList}\small\item\em low-\/level code to check Tx FIFO level register read the register to get the number of valid data entries in the Tx FIFO memory. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_a6b960dbcbe8c5b4eb8c0be518cececef}{dw\+\_\+apb\+\_\+ssi\+\_\+\+DRx\+\_\+read}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver, uint32\+\_\+t $\ast$value)
\begin{DoxyCompactList}\small\item\em low-\/level code to read buffer from the transmit/receive FIFOs. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_a5a73f35ef3c22fd0f14bb16e8e89abcc}{dw\+\_\+apb\+\_\+ssi\+\_\+\+DRx\+\_\+read\+\_\+16\+\_\+dw}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver, uint32\+\_\+t $\ast$values)
\begin{DoxyCompactList}\small\item\em low-\/level code to read (16b) buffer from the transmit/receive FIFOs. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_aeccc2948494f122b9815f97d001cf2ae}{dw\+\_\+apb\+\_\+ssi\+\_\+\+DRx}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver, uint32\+\_\+t DRx\+\_\+val)
\begin{DoxyCompactList}\small\item\em low-\/level code to write buffer to the transmit/receive FIFOs. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_ab0108db36b4e43e32ba4330361093e0a}{leo\+\_\+spi\+\_\+flash\+\_\+write\+\_\+block\+\_\+protect}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver, int spi\+\_\+device, uint8\+\_\+t block\+\_\+protect\+\_\+en)
\begin{DoxyCompactList}\small\item\em low-\/level code to enable/disable the flash write block protection \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_a1f7a8520c7a8b9fcef07d658b01008e5}{flash\+\_\+read\+\_\+sts\+\_\+reg}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver, uint32\+\_\+t $\ast$value)
\begin{DoxyCompactList}\small\item\em low-\/level code to read flash status register \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_ac5647881f3f50ca5deb9fa445f48f789}{flash\+\_\+check\+\_\+write\+\_\+in\+\_\+prog}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver, uint32\+\_\+t $\ast$value)
\begin{DoxyCompactList}\small\item\em low-\/level code to check flash write in progress bit \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_a372af0fad59593b4c804444c3661bd14}{flash\+\_\+write\+\_\+enable}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver)
\begin{DoxyCompactList}\small\item\em low-\/level code to enable flash write \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_a1e77e453cf060aff1a88b078633365fd}{flash\+\_\+subsector\+\_\+erase}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver, uint32\+\_\+t addr, int spi\+Device, int protect)
\begin{DoxyCompactList}\small\item\em low-\/level code to erase flash subsectors (4KB) \end{DoxyCompactList}\item 
\mbox{\Hypertarget{leo__spi_8h_a08b368c568fbe63b6cab149baa93622c}\label{leo__spi_8h_a08b368c568fbe63b6cab149baa93622c}} 
void {\bfseries flash\+\_\+block\+\_\+erase} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver, uint32\+\_\+t addr, int spi\+Ddevice, int protect)
\item 
\mbox{\Hypertarget{leo__spi_8h_a5c44164a7ef3b87e7eaaaca1a6752725}\label{leo__spi_8h_a5c44164a7ef3b87e7eaaaca1a6752725}} 
\mbox{\hyperlink{leo__error_8h_a2f7909bc4b30a2692fc751e1d45dd1d1}{Leo\+Error\+Type}} {\bfseries flash\+\_\+erase\+\_\+range} (\mbox{\hyperlink{leo__api__types_8h_ab3871e3352cab46331ebcfd4026dad31}{Leo\+Device\+Type}} $\ast$leo\+Device, uint32\+\_\+t mem\+\_\+min, uint32\+\_\+t mem\+\_\+max)
\item 
\mbox{\hyperlink{leo__error_8h_a2f7909bc4b30a2692fc751e1d45dd1d1}{Leo\+Error\+Type}} \mbox{\hyperlink{leo__spi_8h_a89b82f93337b1320d4e718a8133a2fe1}{flash\+\_\+write}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver, uint32\+\_\+t start\+\_\+addr, size\+\_\+t num\+\_\+words\+\_\+to\+\_\+write, uint32\+\_\+t $\ast$word\+\_\+arr)
\begin{DoxyCompactList}\small\item\em low-\/level code to write words to flash \end{DoxyCompactList}\item 
\mbox{\hyperlink{leo__error_8h_a2f7909bc4b30a2692fc751e1d45dd1d1}{Leo\+Error\+Type}} \mbox{\hyperlink{leo__spi_8h_a4e22bdaeec9afbd43bde4be967e546a8}{flash\+\_\+read}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver, uint32\+\_\+t start\+\_\+addr, size\+\_\+t num\+\_\+words\+\_\+to\+\_\+read, uint32\+\_\+t $\ast$values)
\begin{DoxyCompactList}\small\item\em low-\/level code to read words from flash \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_a555f6d11a9ce124e546ebb876b7d29bf}{leo\+\_\+spi\+\_\+flash\+\_\+bulk\+\_\+erase}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver)
\begin{DoxyCompactList}\small\item\em low-\/level code to erase entire flash chip. The Chip-\/\+Erase instruction clears all bits in the device to ‘\+F’ The Chip-\/\+Erase instruction is ignored if any of the memory area is protected. Prior to any write operation, it is required to execute the \mbox{\hyperlink{leo__spi_8h_a372af0fad59593b4c804444c3661bd14}{flash\+\_\+write\+\_\+enable()}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_a987e5a5d3d2d6a395058d764fa224886}{flash\+\_\+read\+\_\+jedec}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver, uint32\+\_\+t $\ast$value)
\begin{DoxyCompactList}\small\item\em low-\/level code to read the unique JEDEC ID of the flash chip \end{DoxyCompactList}\item 
void \mbox{\hyperlink{leo__spi_8h_a7f558eae796949ed9bd0005a722791fa}{read\+\_\+fw\+\_\+version}} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver, uint32\+\_\+t $\ast$values)
\begin{DoxyCompactList}\small\item\em low-\/level code to read the unique version of the FW \end{DoxyCompactList}\item 
\mbox{\Hypertarget{leo__spi_8h_ad8bac07a3bc6fe9f3405dde69fded111}\label{leo__spi_8h_ad8bac07a3bc6fe9f3405dde69fded111}} 
\mbox{\hyperlink{leo__error_8h_a2f7909bc4b30a2692fc751e1d45dd1d1}{Leo\+Error\+Type}} {\bfseries flash\+\_\+verify\+\_\+block\+\_\+crc} (\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$leo\+Driver, uint32\+\_\+t start\+Addr, size\+\_\+t len\+DWords, uint32\+\_\+t crc)
\item 
\mbox{\hyperlink{leo__error_8h_a2f7909bc4b30a2692fc751e1d45dd1d1}{Leo\+Error\+Type}} \mbox{\hyperlink{leo__spi_8h_acec3a54ac19f3190c1885ea203635be8}{leo\+\_\+spi\+\_\+program\+\_\+flash}} (\mbox{\hyperlink{leo__api__types_8h_ab3871e3352cab46331ebcfd4026dad31}{Leo\+Device\+Type}} $\ast$leo\+Device, const char $\ast$filename)
\begin{DoxyCompactList}\small\item\em program Leo SPI with the new flash memory \end{DoxyCompactList}\item 
\mbox{\Hypertarget{leo__spi_8h_a8266ac22047a8799fc589217e577089b}\label{leo__spi_8h_a8266ac22047a8799fc589217e577089b}} 
\mbox{\hyperlink{leo__error_8h_a2f7909bc4b30a2692fc751e1d45dd1d1}{Leo\+Error\+Type}} {\bfseries leo\+\_\+spi\+\_\+update\+\_\+target} (\mbox{\hyperlink{leo__api__types_8h_ab3871e3352cab46331ebcfd4026dad31}{Leo\+Device\+Type}} $\ast$device, char $\ast$filename, int target, int verify)
\item 
\mbox{\Hypertarget{leo__spi_8h_a2348486f5a15fc86ae72dcd4765003eb}\label{leo__spi_8h_a2348486f5a15fc86ae72dcd4765003eb}} 
\mbox{\hyperlink{leo__error_8h_a2f7909bc4b30a2692fc751e1d45dd1d1}{Leo\+Error\+Type}} {\bfseries leo\+\_\+spi\+\_\+verify\+\_\+crc} (\mbox{\hyperlink{leo__api__types_8h_ab3871e3352cab46331ebcfd4026dad31}{Leo\+Device\+Type}} $\ast$device, char $\ast$filename)
\item 
\mbox{\Hypertarget{leo__spi_8h_a63cd7b2b9ee24c06ca23a0959cbf79db}\label{leo__spi_8h_a63cd7b2b9ee24c06ca23a0959cbf79db}} 
\mbox{\hyperlink{leo__error_8h_a2f7909bc4b30a2692fc751e1d45dd1d1}{Leo\+Error\+Type}} {\bfseries leo\+Spi\+Check\+Compatibility} (\mbox{\hyperlink{leo__api__types_8h_ab3871e3352cab46331ebcfd4026dad31}{Leo\+Device\+Type}} $\ast$device, uint8\+\_\+t $\ast$fw\+Buf)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Definition of SPI types for the SDK. 



\doxysubsection{Function Documentation}
\mbox{\Hypertarget{leo__spi_8h_a9ca9f0deb9da8eae88efb1be873f4c6b}\label{leo__spi_8h_a9ca9f0deb9da8eae88efb1be873f4c6b}} 
\index{leo\_spi.h@{leo\_spi.h}!asteraSPIBlockErase@{asteraSPIBlockErase}}
\index{asteraSPIBlockErase@{asteraSPIBlockErase}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{asteraSPIBlockErase()}{asteraSPIBlockErase()}}
{\footnotesize\ttfamily void astera\+SPIBlock\+Erase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}}}]{product,  }\item[{uint32\+\_\+t}]{block\+\_\+addr,  }\item[{uint32\+\_\+t}]{block\+\_\+count }\end{DoxyParamCaption})}



Low-\/level block erase SPI function. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. This function erases one or more blocks of memory specified by the address. 


\begin{DoxyParams}{Parameters}
{\em block\+\_\+addr} & \+: Address of the block to erase \\
\hline
{\em block\+\_\+count} & \+: Number of blocks to erase \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_aaa3bb1a48505737c84aaf11bb2ec23ed}\label{leo__spi_8h_aaa3bb1a48505737c84aaf11bb2ec23ed}} 
\index{leo\_spi.h@{leo\_spi.h}!asteraSPIChipBulkErase@{asteraSPIChipBulkErase}}
\index{asteraSPIChipBulkErase@{asteraSPIChipBulkErase}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{asteraSPIChipBulkErase()}{asteraSPIChipBulkErase()}}
{\footnotesize\ttfamily void astera\+SPIChip\+Bulk\+Erase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}}}]{product }\end{DoxyParamCaption})}



Low-\/level SPI API to completely bulk erase the flash chip THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. This function erases the entire flash chip. 

\mbox{\Hypertarget{leo__spi_8h_ae7dca44511b92f3a219d53c4e9685d70}\label{leo__spi_8h_ae7dca44511b92f3a219d53c4e9685d70}} 
\index{leo\_spi.h@{leo\_spi.h}!asteraSPIClose@{asteraSPIClose}}
\index{asteraSPIClose@{asteraSPIClose}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{asteraSPIClose()}{asteraSPIClose()}}
{\footnotesize\ttfamily void astera\+SPIClose (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}}}]{product }\end{DoxyParamCaption})}



Low-\/level SPI Initialization and setup. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. This function is called to close the SPI device. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Product\+Type} & (Leo) \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_a047259b839e2dafc169d995997311c1c}\label{leo__spi_8h_a047259b839e2dafc169d995997311c1c}} 
\index{leo\_spi.h@{leo\_spi.h}!asteraSPIRead@{asteraSPIRead}}
\index{asteraSPIRead@{asteraSPIRead}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{asteraSPIRead()}{asteraSPIRead()}}
{\footnotesize\ttfamily unsigned char astera\+SPIRead (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}}}]{product,  }\item[{uint32\+\_\+t}]{addr }\end{DoxyParamCaption})}



Low-\/level SPI Read. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. reads one byte from the SPI bus at the address specified. 


\begin{DoxyParams}{Parameters}
{\em addr} & \+: Address of the byte to read from \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_a38bd047aed25ead22942d189cbde06df}\label{leo__spi_8h_a38bd047aed25ead22942d189cbde06df}} 
\index{leo\_spi.h@{leo\_spi.h}!asteraSPIReadBlock@{asteraSPIReadBlock}}
\index{asteraSPIReadBlock@{asteraSPIReadBlock}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{asteraSPIReadBlock()}{asteraSPIReadBlock()}}
{\footnotesize\ttfamily void astera\+SPIRead\+Block (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}}}]{product,  }\item[{uint32\+\_\+t}]{addr,  }\item[{uint8\+\_\+t $\ast$}]{data,  }\item[{uint32\+\_\+t}]{len }\end{DoxyParamCaption})}



Low-\/level SPI Read Block. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. reads a block of bytes into the given array from the SPI bus at the address specified. 


\begin{DoxyParams}{Parameters}
{\em addr} & \+: address to read from \\
\hline
{\em data} & \+: pointer to the array to store the data that was read \\
\hline
{\em size} & \+: number of bytes to read \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_a8e393dac017a7638b0762d5a9bdd7300}\label{leo__spi_8h_a8e393dac017a7638b0762d5a9bdd7300}} 
\index{leo\_spi.h@{leo\_spi.h}!asteraSPIReadPage@{asteraSPIReadPage}}
\index{asteraSPIReadPage@{asteraSPIReadPage}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{asteraSPIReadPage()}{asteraSPIReadPage()}}
{\footnotesize\ttfamily void astera\+SPIRead\+Page (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}}}]{product,  }\item[{uint32\+\_\+t}]{addr,  }\item[{uint8\+\_\+t $\ast$}]{data,  }\item[{uint32\+\_\+t}]{len }\end{DoxyParamCaption})}



Low-\/level SPI Read Page. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. Reads the number of pages desired from SPI bus at the address specified. 


\begin{DoxyParams}{Parameters}
{\em addr} & \+: Address of the byte to read from \\
\hline
{\em data} & \+: pointer to the array to store the data that was read \\
\hline
{\em size} & \+: number of bytes to read \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_a86419b4256b0bf5e099fa746cbcf8e8d}\label{leo__spi_8h_a86419b4256b0bf5e099fa746cbcf8e8d}} 
\index{leo\_spi.h@{leo\_spi.h}!asteraSPISetup@{asteraSPISetup}}
\index{asteraSPISetup@{asteraSPISetup}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{asteraSPISetup()}{asteraSPISetup()}}
{\footnotesize\ttfamily void astera\+SPISetup (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}}}]{product }\end{DoxyParamCaption})}



Low-\/level SPI Initialization and setup. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. This function has to be called before any other SPI function. Initialize and Open the SPI driver, setup the clocks, Pin signals, baud rate, and other SPI parameters. 

\mbox{\Hypertarget{leo__spi_8h_a7edff1078270d42f03e8a236fa39e18c}\label{leo__spi_8h_a7edff1078270d42f03e8a236fa39e18c}} 
\index{leo\_spi.h@{leo\_spi.h}!asteraSPIWrite@{asteraSPIWrite}}
\index{asteraSPIWrite@{asteraSPIWrite}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{asteraSPIWrite()}{asteraSPIWrite()}}
{\footnotesize\ttfamily void astera\+SPIWrite (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}}}]{product,  }\item[{uint32\+\_\+t}]{addr,  }\item[{uint8\+\_\+t $\ast$}]{data,  }\item[{uint32\+\_\+t}]{len }\end{DoxyParamCaption})}



Low-\/level SPI Write. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. writes a sequence of bytes to the SPI bus at the address specified the flash cells are not autmatically erased, it is important to clear the flash cells by calling the erase function before writing to the flash. 


\begin{DoxyParams}{Parameters}
{\em addr} & \+: The position in the flash to write the first byte \\
\hline
{\em data} & \+: The data to write to the flash \\
\hline
{\em len} & \+: The number of bytes to write \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_a6f8ccdac75eb92fd6b347a5fc8418726}\label{leo__spi_8h_a6f8ccdac75eb92fd6b347a5fc8418726}} 
\index{leo\_spi.h@{leo\_spi.h}!asteraSPIWriteBlock@{asteraSPIWriteBlock}}
\index{asteraSPIWriteBlock@{asteraSPIWriteBlock}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{asteraSPIWriteBlock()}{asteraSPIWriteBlock()}}
{\footnotesize\ttfamily void astera\+SPIWrite\+Block (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}}}]{product,  }\item[{uint32\+\_\+t}]{addr,  }\item[{uint8\+\_\+t $\ast$}]{data,  }\item[{uint32\+\_\+t}]{len }\end{DoxyParamCaption})}



Low-\/level SPI Write Block. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. writes a block of bytes to the SPI bus at the address specified. 


\begin{DoxyParams}{Parameters}
{\em addr} & \+: The position in the flash to write the first byte \\
\hline
{\em data} & \+: The data to write to the flash \\
\hline
{\em len} & \+: The number of bytes to write \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_ab791f034fc71dd22cd28bd7976e2d441}\label{leo__spi_8h_ab791f034fc71dd22cd28bd7976e2d441}} 
\index{leo\_spi.h@{leo\_spi.h}!asteraSPIWritePage@{asteraSPIWritePage}}
\index{asteraSPIWritePage@{asteraSPIWritePage}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{asteraSPIWritePage()}{asteraSPIWritePage()}}
{\footnotesize\ttfamily void astera\+SPIWrite\+Page (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__globals_8h_adea96f6482bfe75f7a5df44d48142691}{Astera\+Product\+Type}}}]{product,  }\item[{uint32\+\_\+t}]{addr,  }\item[{uint8\+\_\+t $\ast$}]{data,  }\item[{uint32\+\_\+t}]{len }\end{DoxyParamCaption})}



Low-\/level SPI Write Page. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER\textquotesingle{}S APPLICATION. Writes the number of pages desired to the SPI bus at the address specified. 


\begin{DoxyParams}{Parameters}
{\em addr} & \+: The position in the flash to write the first byte \\
\hline
{\em data} & \+: The data to write to the flash \\
\hline
{\em len} & \+: The number of bytes to write \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_a9295236392c024299336aea54004513c}\label{leo__spi_8h_a9295236392c024299336aea54004513c}} 
\index{leo\_spi.h@{leo\_spi.h}!dw\_apb\_ssi\_CTRLR0@{dw\_apb\_ssi\_CTRLR0}}
\index{dw\_apb\_ssi\_CTRLR0@{dw\_apb\_ssi\_CTRLR0}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{dw\_apb\_ssi\_CTRLR0()}{dw\_apb\_ssi\_CTRLR0()}}
{\footnotesize\ttfamily void dw\+\_\+apb\+\_\+ssi\+\_\+\+CTRLR0 (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver,  }\item[{uint32\+\_\+t}]{CTRLR0\+\_\+val }\end{DoxyParamCaption})}



low-\/level code to control the serial data transfer Cannot write into this register while DW APB SSI is enabled Valid only when DW APB SSI is configured as a master device. 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver \\
\hline
{\em CTRLR0\+\_\+val} & SPI Frame format, Data \& Control Frame Size, transfer mode, Serial Clock Polarity, Serial Clock Phase. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_a9a312f0a56397e468f5c7dfecfafcdca}\label{leo__spi_8h_a9a312f0a56397e468f5c7dfecfafcdca}} 
\index{leo\_spi.h@{leo\_spi.h}!dw\_apb\_ssi\_CTRLR1@{dw\_apb\_ssi\_CTRLR1}}
\index{dw\_apb\_ssi\_CTRLR1@{dw\_apb\_ssi\_CTRLR1}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{dw\_apb\_ssi\_CTRLR1()}{dw\_apb\_ssi\_CTRLR1()}}
{\footnotesize\ttfamily void dw\+\_\+apb\+\_\+ssi\+\_\+\+CTRLR1 (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver,  }\item[{uint32\+\_\+t}]{CTRLR1\+\_\+val }\end{DoxyParamCaption})}



low-\/level code to control the end of serial data transfers when in Rx mode. Cannot write into this register while DW APB SSI is enabled Valid only when DW APB SSI is configured as a master device. The DW\+\_\+apb\+\_\+ssi continues to rx serial data until the number of data frames received is equal to this register value plus 1. 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver \\
\hline
{\em CTRLR1\+\_\+val} & Number of data frames in a transfer \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_aeccc2948494f122b9815f97d001cf2ae}\label{leo__spi_8h_aeccc2948494f122b9815f97d001cf2ae}} 
\index{leo\_spi.h@{leo\_spi.h}!dw\_apb\_ssi\_DRx@{dw\_apb\_ssi\_DRx}}
\index{dw\_apb\_ssi\_DRx@{dw\_apb\_ssi\_DRx}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{dw\_apb\_ssi\_DRx()}{dw\_apb\_ssi\_DRx()}}
{\footnotesize\ttfamily void dw\+\_\+apb\+\_\+ssi\+\_\+\+DRx (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver,  }\item[{uint32\+\_\+t}]{DRx\+\_\+val }\end{DoxyParamCaption})}



low-\/level code to write buffer to the transmit/receive FIFOs. 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver \\
\hline
{\em value} & value to write to the transmit/receive FIFOs \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_a6b960dbcbe8c5b4eb8c0be518cececef}\label{leo__spi_8h_a6b960dbcbe8c5b4eb8c0be518cececef}} 
\index{leo\_spi.h@{leo\_spi.h}!dw\_apb\_ssi\_DRx\_read@{dw\_apb\_ssi\_DRx\_read}}
\index{dw\_apb\_ssi\_DRx\_read@{dw\_apb\_ssi\_DRx\_read}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{dw\_apb\_ssi\_DRx\_read()}{dw\_apb\_ssi\_DRx\_read()}}
{\footnotesize\ttfamily void dw\+\_\+apb\+\_\+ssi\+\_\+\+DRx\+\_\+read (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver,  }\item[{uint32\+\_\+t $\ast$}]{value }\end{DoxyParamCaption})}



low-\/level code to read buffer from the transmit/receive FIFOs. 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver \\
\hline
{\em value} & value read from the transmit/receive FIFOs \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_a5a73f35ef3c22fd0f14bb16e8e89abcc}\label{leo__spi_8h_a5a73f35ef3c22fd0f14bb16e8e89abcc}} 
\index{leo\_spi.h@{leo\_spi.h}!dw\_apb\_ssi\_DRx\_read\_16\_dw@{dw\_apb\_ssi\_DRx\_read\_16\_dw}}
\index{dw\_apb\_ssi\_DRx\_read\_16\_dw@{dw\_apb\_ssi\_DRx\_read\_16\_dw}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{dw\_apb\_ssi\_DRx\_read\_16\_dw()}{dw\_apb\_ssi\_DRx\_read\_16\_dw()}}
{\footnotesize\ttfamily void dw\+\_\+apb\+\_\+ssi\+\_\+\+DRx\+\_\+read\+\_\+16\+\_\+dw (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver,  }\item[{uint32\+\_\+t $\ast$}]{values }\end{DoxyParamCaption})}



low-\/level code to read (16b) buffer from the transmit/receive FIFOs. 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver \\
\hline
{\em value} & value read (16b) from the transmit/receive FIFOs \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_a86be803c04c299a120984588c3f1687d}\label{leo__spi_8h_a86be803c04c299a120984588c3f1687d}} 
\index{leo\_spi.h@{leo\_spi.h}!dw\_apb\_ssi\_RXFLR@{dw\_apb\_ssi\_RXFLR}}
\index{dw\_apb\_ssi\_RXFLR@{dw\_apb\_ssi\_RXFLR}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{dw\_apb\_ssi\_RXFLR()}{dw\_apb\_ssi\_RXFLR()}}
{\footnotesize\ttfamily void dw\+\_\+apb\+\_\+ssi\+\_\+\+RXFLR (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver,  }\item[{uint32\+\_\+t $\ast$}]{value }\end{DoxyParamCaption})}



low-\/level code to check Rx FIFO level register read the register to get the number of valid data entries in the Rx FIFO memory. 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver \\
\hline
{\em value} & number of valid data entries in the Rx FIFO memory \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_abf7b785d49d9ec872c4e155ef6fb38b3}\label{leo__spi_8h_abf7b785d49d9ec872c4e155ef6fb38b3}} 
\index{leo\_spi.h@{leo\_spi.h}!dw\_apb\_ssi\_SER@{dw\_apb\_ssi\_SER}}
\index{dw\_apb\_ssi\_SER@{dw\_apb\_ssi\_SER}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{dw\_apb\_ssi\_SER()}{dw\_apb\_ssi\_SER()}}
{\footnotesize\ttfamily void dw\+\_\+apb\+\_\+ssi\+\_\+\+SER (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver,  }\item[{uint32\+\_\+t}]{enable }\end{DoxyParamCaption})}



low-\/level code to select/not select slave device by using the Slave Enable Register in DW APB SSI Valid only when DW APB SSI is configured as a master device. 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver \\
\hline
{\em enable} & 1 means slave is selected, 0 means no slave is selected \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_a5235ae236a0f3ddd6938092e548429d6}\label{leo__spi_8h_a5235ae236a0f3ddd6938092e548429d6}} 
\index{leo\_spi.h@{leo\_spi.h}!dw\_apb\_ssi\_SSIENR@{dw\_apb\_ssi\_SSIENR}}
\index{dw\_apb\_ssi\_SSIENR@{dw\_apb\_ssi\_SSIENR}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{dw\_apb\_ssi\_SSIENR()}{dw\_apb\_ssi\_SSIENR()}}
{\footnotesize\ttfamily void dw\+\_\+apb\+\_\+ssi\+\_\+\+SSIENR (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver,  }\item[{uint32\+\_\+t}]{enable }\end{DoxyParamCaption})}



low-\/level code to enable/disable the DW APB SSI 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver \\
\hline
{\em enable} & 1 to enable, 0 to disable \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_acdc9617db34e6fad7f78da066eb4632b}\label{leo__spi_8h_acdc9617db34e6fad7f78da066eb4632b}} 
\index{leo\_spi.h@{leo\_spi.h}!dw\_apb\_ssi\_TXFLR@{dw\_apb\_ssi\_TXFLR}}
\index{dw\_apb\_ssi\_TXFLR@{dw\_apb\_ssi\_TXFLR}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{dw\_apb\_ssi\_TXFLR()}{dw\_apb\_ssi\_TXFLR()}}
{\footnotesize\ttfamily void dw\+\_\+apb\+\_\+ssi\+\_\+\+TXFLR (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver,  }\item[{uint32\+\_\+t $\ast$}]{value }\end{DoxyParamCaption})}



low-\/level code to check Tx FIFO level register read the register to get the number of valid data entries in the Tx FIFO memory. 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver \\
\hline
{\em value} & number of valid data entries in the Transmit FIFO memory \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_ac5647881f3f50ca5deb9fa445f48f789}\label{leo__spi_8h_ac5647881f3f50ca5deb9fa445f48f789}} 
\index{leo\_spi.h@{leo\_spi.h}!flash\_check\_write\_in\_prog@{flash\_check\_write\_in\_prog}}
\index{flash\_check\_write\_in\_prog@{flash\_check\_write\_in\_prog}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{flash\_check\_write\_in\_prog()}{flash\_check\_write\_in\_prog()}}
{\footnotesize\ttfamily void flash\+\_\+check\+\_\+write\+\_\+in\+\_\+prog (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver,  }\item[{uint32\+\_\+t $\ast$}]{value }\end{DoxyParamCaption})}



low-\/level code to check flash write in progress bit 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver \\
\hline
{\em value} & value determines if flash write is in progress \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_a4e22bdaeec9afbd43bde4be967e546a8}\label{leo__spi_8h_a4e22bdaeec9afbd43bde4be967e546a8}} 
\index{leo\_spi.h@{leo\_spi.h}!flash\_read@{flash\_read}}
\index{flash\_read@{flash\_read}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{flash\_read()}{flash\_read()}}
{\footnotesize\ttfamily \mbox{\hyperlink{leo__error_8h_a2f7909bc4b30a2692fc751e1d45dd1d1}{Leo\+Error\+Type}} flash\+\_\+read (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver,  }\item[{uint32\+\_\+t}]{start\+\_\+addr,  }\item[{size\+\_\+t}]{num\+\_\+words\+\_\+to\+\_\+read,  }\item[{uint32\+\_\+t $\ast$}]{values }\end{DoxyParamCaption})}



low-\/level code to read words from flash 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver \\
\hline
{\em start\+\_\+addr} & start address of the flash to be read \\
\hline
{\em num\+\_\+words} & number of words to be read \\
\hline
{\em word\+\_\+arr} & pointer to the data to be read \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Leo\+Error\+Type 
\end{DoxyReturn}
\mbox{\Hypertarget{leo__spi_8h_a987e5a5d3d2d6a395058d764fa224886}\label{leo__spi_8h_a987e5a5d3d2d6a395058d764fa224886}} 
\index{leo\_spi.h@{leo\_spi.h}!flash\_read\_jedec@{flash\_read\_jedec}}
\index{flash\_read\_jedec@{flash\_read\_jedec}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{flash\_read\_jedec()}{flash\_read\_jedec()}}
{\footnotesize\ttfamily void flash\+\_\+read\+\_\+jedec (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver,  }\item[{uint32\+\_\+t $\ast$}]{value }\end{DoxyParamCaption})}



low-\/level code to read the unique JEDEC ID of the flash chip 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver \\
\hline
{\em value} & value read (JEDEC ID) \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_a1f7a8520c7a8b9fcef07d658b01008e5}\label{leo__spi_8h_a1f7a8520c7a8b9fcef07d658b01008e5}} 
\index{leo\_spi.h@{leo\_spi.h}!flash\_read\_sts\_reg@{flash\_read\_sts\_reg}}
\index{flash\_read\_sts\_reg@{flash\_read\_sts\_reg}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{flash\_read\_sts\_reg()}{flash\_read\_sts\_reg()}}
{\footnotesize\ttfamily void flash\+\_\+read\+\_\+sts\+\_\+reg (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver,  }\item[{uint32\+\_\+t $\ast$}]{value }\end{DoxyParamCaption})}



low-\/level code to read flash status register 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver \\
\hline
{\em value} & value read from the flash status register \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_a1e77e453cf060aff1a88b078633365fd}\label{leo__spi_8h_a1e77e453cf060aff1a88b078633365fd}} 
\index{leo\_spi.h@{leo\_spi.h}!flash\_subsector\_erase@{flash\_subsector\_erase}}
\index{flash\_subsector\_erase@{flash\_subsector\_erase}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{flash\_subsector\_erase()}{flash\_subsector\_erase()}}
{\footnotesize\ttfamily void flash\+\_\+subsector\+\_\+erase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver,  }\item[{uint32\+\_\+t}]{addr,  }\item[{int}]{spi\+Device,  }\item[{int}]{protect }\end{DoxyParamCaption})}



low-\/level code to erase flash subsectors (4KB) 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver \\
\hline
{\em addr} & address of the flash subsector to be erased \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_a89b82f93337b1320d4e718a8133a2fe1}\label{leo__spi_8h_a89b82f93337b1320d4e718a8133a2fe1}} 
\index{leo\_spi.h@{leo\_spi.h}!flash\_write@{flash\_write}}
\index{flash\_write@{flash\_write}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{flash\_write()}{flash\_write()}}
{\footnotesize\ttfamily \mbox{\hyperlink{leo__error_8h_a2f7909bc4b30a2692fc751e1d45dd1d1}{Leo\+Error\+Type}} flash\+\_\+write (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver,  }\item[{uint32\+\_\+t}]{start\+\_\+addr,  }\item[{size\+\_\+t}]{num\+\_\+words\+\_\+to\+\_\+write,  }\item[{uint32\+\_\+t $\ast$}]{word\+\_\+arr }\end{DoxyParamCaption})}



low-\/level code to write words to flash 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver \\
\hline
{\em start\+\_\+addr} & start address of the flash to be written \\
\hline
{\em num\+\_\+words} & number of words to be written \\
\hline
{\em word\+\_\+arr} & pointer to the data to be written \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Leo\+Error\+Type 
\end{DoxyReturn}
\mbox{\Hypertarget{leo__spi_8h_a372af0fad59593b4c804444c3661bd14}\label{leo__spi_8h_a372af0fad59593b4c804444c3661bd14}} 
\index{leo\_spi.h@{leo\_spi.h}!flash\_write\_enable@{flash\_write\_enable}}
\index{flash\_write\_enable@{flash\_write\_enable}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{flash\_write\_enable()}{flash\_write\_enable()}}
{\footnotesize\ttfamily void flash\+\_\+write\+\_\+enable (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver }\end{DoxyParamCaption})}



low-\/level code to enable flash write 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_a555f6d11a9ce124e546ebb876b7d29bf}\label{leo__spi_8h_a555f6d11a9ce124e546ebb876b7d29bf}} 
\index{leo\_spi.h@{leo\_spi.h}!leo\_spi\_flash\_bulk\_erase@{leo\_spi\_flash\_bulk\_erase}}
\index{leo\_spi\_flash\_bulk\_erase@{leo\_spi\_flash\_bulk\_erase}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{leo\_spi\_flash\_bulk\_erase()}{leo\_spi\_flash\_bulk\_erase()}}
{\footnotesize\ttfamily void leo\+\_\+spi\+\_\+flash\+\_\+bulk\+\_\+erase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver }\end{DoxyParamCaption})}



low-\/level code to erase entire flash chip. The Chip-\/\+Erase instruction clears all bits in the device to ‘\+F’ The Chip-\/\+Erase instruction is ignored if any of the memory area is protected. Prior to any write operation, it is required to execute the \mbox{\hyperlink{leo__spi_8h_a372af0fad59593b4c804444c3661bd14}{flash\+\_\+write\+\_\+enable()}}. 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_ab0108db36b4e43e32ba4330361093e0a}\label{leo__spi_8h_ab0108db36b4e43e32ba4330361093e0a}} 
\index{leo\_spi.h@{leo\_spi.h}!leo\_spi\_flash\_write\_block\_protect@{leo\_spi\_flash\_write\_block\_protect}}
\index{leo\_spi\_flash\_write\_block\_protect@{leo\_spi\_flash\_write\_block\_protect}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{leo\_spi\_flash\_write\_block\_protect()}{leo\_spi\_flash\_write\_block\_protect()}}
{\footnotesize\ttfamily void leo\+\_\+spi\+\_\+flash\+\_\+write\+\_\+block\+\_\+protect (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver,  }\item[{int}]{spi\+\_\+device,  }\item[{uint8\+\_\+t}]{block\+\_\+protect\+\_\+en }\end{DoxyParamCaption})}



low-\/level code to enable/disable the flash write block protection 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver \\
\hline
{\em spi\+\_\+device} & type of spi device -\/ some don\textquotesingle{}t support write block protect command \\
\hline
{\em value} & 1 to enable, 0 to disable \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_acec3a54ac19f3190c1885ea203635be8}\label{leo__spi_8h_acec3a54ac19f3190c1885ea203635be8}} 
\index{leo\_spi.h@{leo\_spi.h}!leo\_spi\_program\_flash@{leo\_spi\_program\_flash}}
\index{leo\_spi\_program\_flash@{leo\_spi\_program\_flash}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{leo\_spi\_program\_flash()}{leo\_spi\_program\_flash()}}
{\footnotesize\ttfamily \mbox{\hyperlink{leo__error_8h_a2f7909bc4b30a2692fc751e1d45dd1d1}{Leo\+Error\+Type}} leo\+\_\+spi\+\_\+program\+\_\+flash (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_ab3871e3352cab46331ebcfd4026dad31}{Leo\+Device\+Type}} $\ast$}]{leo\+Device,  }\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})}



program Leo SPI with the new flash memory 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em leo\+Device} & pointer to the device \\
\hline
\mbox{\texttt{ in}}  & {\em flash\+File\+Name} & filepath name \\
\hline
\mbox{\texttt{ in}}  & {\em persistent\+Data\+Buf} & data to be written into persistent data block \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{leo__spi_8h_a8af0705d1a24d00713885b205c5d6840}\label{leo__spi_8h_a8af0705d1a24d00713885b205c5d6840}} 
\index{leo\_spi.h@{leo\_spi.h}!leoSpiInit@{leoSpiInit}}
\index{leoSpiInit@{leoSpiInit}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{leoSpiInit()}{leoSpiInit()}}
{\footnotesize\ttfamily void leo\+Spi\+Init (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver }\end{DoxyParamCaption})}



Low-\/level code to initialize the DW APB. 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver\\
\hline
\end{DoxyParams}
Low-\/level code to initialize the DW APB. \mbox{\Hypertarget{leo__spi_8h_a7f558eae796949ed9bd0005a722791fa}\label{leo__spi_8h_a7f558eae796949ed9bd0005a722791fa}} 
\index{leo\_spi.h@{leo\_spi.h}!read\_fw\_version@{read\_fw\_version}}
\index{read\_fw\_version@{read\_fw\_version}!leo\_spi.h@{leo\_spi.h}}
\doxysubsubsection{\texorpdfstring{read\_fw\_version()}{read\_fw\_version()}}
{\footnotesize\ttfamily void read\+\_\+fw\+\_\+version (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{leo__api__types_8h_a0e1807c16a7c4406767cc816f126d753}{Leo\+I2\+CDriver\+Type}} $\ast$}]{leo\+Driver,  }\item[{uint32\+\_\+t $\ast$}]{values }\end{DoxyParamCaption})}



low-\/level code to read the unique version of the FW 


\begin{DoxyParams}{Parameters}
{\em leo\+Driver} & pointer to the Leo driver \\
\hline
{\em value} & value read (FW version) \\
\hline
\end{DoxyParams}
