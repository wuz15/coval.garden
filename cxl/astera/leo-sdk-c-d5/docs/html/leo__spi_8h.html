<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Leo CXL Smart Memory Controller: leo-sdk-c/include/leo_spi.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Leo CXL Smart Memory Controller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('leo__spi_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">leo_spi.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Definition of SPI types for the SDK.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="DW__apb__ssi_8h_source.html">DW_apb_ssi.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="leo__api__types_8h_source.html">leo_api_types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="leo__error_8h_source.html">leo_error.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="leo__globals_8h_source.html">leo_globals.h</a>&quot;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for leo_spi.h:</div>
<div class="dyncontent">
<div class="center"><img src="leo__spi_8h__incl.png" border="0" usemap="#aleo-sdk-c_2include_2leo__spi_8h" alt=""/></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="leo__spi_8h__dep__incl.png" border="0" usemap="#aleo-sdk-c_2include_2leo__spi_8hdep" alt=""/></div>
</div>
</div>
<p><a href="leo__spi_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structblock__info.html">block_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtoc__code__data.html">toc_code_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtoc__syscfg__data.html">toc_syscfg_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtoc__config.html">toc_config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtoc__data.html">toc_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLeoSpiDescriptionEntryType.html">LeoSpiDescriptionEntryType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLeoSpiDescriptionBlockDataType.html">LeoSpiDescriptionBlockDataType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflash__boot__load__ctrl__info__t.html">flash_boot_load_ctrl_info_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a654e4d43534f3335ac1cb9b694ff204b"><td class="memItemLeft" align="right" valign="top"><a id="a654e4d43534f3335ac1cb9b694ff204b" name="a654e4d43534f3335ac1cb9b694ff204b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPI_FLASH_SIZE</b>&#160;&#160;&#160;(8 * 1024 * 1024)</td></tr>
<tr class="separator:a654e4d43534f3335ac1cb9b694ff204b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b9727caca176f18a4de8bc8293533d"><td class="memItemLeft" align="right" valign="top"><a id="af5b9727caca176f18a4de8bc8293533d" name="af5b9727caca176f18a4de8bc8293533d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LEO_SPI_FLASH_HEADER_BYTE_CNT</b>&#160;&#160;&#160;(0x24)</td></tr>
<tr class="separator:af5b9727caca176f18a4de8bc8293533d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3d0728e92b0ba4b0f63f81de4f0e5e93"><td class="memItemLeft" align="right" valign="top"><a id="a3d0728e92b0ba4b0f63f81de4f0e5e93" name="a3d0728e92b0ba4b0f63f81de4f0e5e93"></a>
typedef struct <a class="el" href="structblock__info.html">block_info</a>&#160;</td><td class="memItemRight" valign="bottom"><b>block_info_t</b></td></tr>
<tr class="separator:a3d0728e92b0ba4b0f63f81de4f0e5e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d41b0f5f19c45da19d89e7314e4df4"><td class="memItemLeft" align="right" valign="top"><a id="a87d41b0f5f19c45da19d89e7314e4df4" name="a87d41b0f5f19c45da19d89e7314e4df4"></a>
typedef struct <a class="el" href="structtoc__code__data.html">toc_code_data</a>&#160;</td><td class="memItemRight" valign="bottom"><b>toc_code_data_t</b></td></tr>
<tr class="separator:a87d41b0f5f19c45da19d89e7314e4df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8890b5cb62d25e0b4126ff698e4a265c"><td class="memItemLeft" align="right" valign="top"><a id="a8890b5cb62d25e0b4126ff698e4a265c" name="a8890b5cb62d25e0b4126ff698e4a265c"></a>
typedef struct <a class="el" href="structtoc__syscfg__data.html">toc_syscfg_data</a>&#160;</td><td class="memItemRight" valign="bottom"><b>toc_syscfg_data_t</b></td></tr>
<tr class="separator:a8890b5cb62d25e0b4126ff698e4a265c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb30e0384fc0a25913163340627364b5"><td class="memItemLeft" align="right" valign="top"><a id="abb30e0384fc0a25913163340627364b5" name="abb30e0384fc0a25913163340627364b5"></a>
typedef struct <a class="el" href="structtoc__config.html">toc_config</a>&#160;</td><td class="memItemRight" valign="bottom"><b>toc_config_t</b></td></tr>
<tr class="separator:abb30e0384fc0a25913163340627364b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2613ac1579ad1fca176f093d750b9a"><td class="memItemLeft" align="right" valign="top"><a id="a2f2613ac1579ad1fca176f093d750b9a" name="a2f2613ac1579ad1fca176f093d750b9a"></a>
typedef struct <a class="el" href="structtoc__data.html">toc_data</a>&#160;</td><td class="memItemRight" valign="bottom"><b>toc_data_t</b></td></tr>
<tr class="separator:a2f2613ac1579ad1fca176f093d750b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aeb99945dbdc5420f239332d41b4b75f7"><td class="memItemLeft" align="right" valign="top"><a id="aeb99945dbdc5420f239332d41b4b75f7" name="aeb99945dbdc5420f239332d41b4b75f7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>BLOCKTYPE</b> { <br />
&#160;&#160;<b>BT_MAIN_e</b> = 0x01
, <b>BT_SYSTEM_CONFIG_e</b> = 0x04
, <b>BT_PERSISTENT_DATA_e</b> = 0x06
, <b>BT_DESCRIPTION_e</b> = 0x07
, <br />
&#160;&#160;<b>BT_TOC_e</b> = 0x86
, <b>BT_FLASH_CTRL_e</b> = 0x87
, <b>BT_FLASH_RSVD_e</b> = 0xdd
, <b>BT_END_e</b> = 0xff
<br />
 }</td></tr>
<tr class="separator:aeb99945dbdc5420f239332d41b4b75f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c0312ac66c00f31cf886616c48afa2"><td class="memItemLeft" align="right" valign="top"><a id="a26c0312ac66c00f31cf886616c48afa2" name="a26c0312ac66c00f31cf886616c48afa2"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>SPI_DEVICE_SST26WF064C_e</b>
, <b>SPI_DEVICE_MX25U6432_e</b>
, <b>SPI_DEVICE_EOL_e</b>
 }</td></tr>
<tr class="separator:a26c0312ac66c00f31cf886616c48afa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd12a18eeb0ee701fc7b0efd5068266"><td class="memItemLeft" align="right" valign="top"><a id="aecd12a18eeb0ee701fc7b0efd5068266" name="aecd12a18eeb0ee701fc7b0efd5068266"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>FLASH_BOOT_LOAD_STATUS_OK</b> = 0
, <b>FLASH_BOOT_LOAD_READ_DW_STATUS_NO_CMD_ACTIVE</b> = 0x0001
, <b>FLASH_BOOT_LOAD_DW_STATUS_TX_FIFO_OVERFLOW</b> = 0x0002
, <b>FLASH_BOOT_LOAD_DW_STATUS_RX_FIFO_UNDERFLOW</b> = 0x0004
, <br />
&#160;&#160;<b>FLASH_BOOT_LOAD_READ_DW_STATUS_RX_FIFO_OVERFLOW</b> = 0x0008
, <b>FLASH_BOOT_LOAD_ERROR_TIMEOUT</b> = 0x0010
, <b>FLASH_BOOT_LOAD_ERROR_STILL_BUSY</b> = 0x0020
, <b>FLASH_BOOT_LOAD_ERROR_ADDR_MIS_MATCH</b> = 0x0040
<br />
 }</td></tr>
<tr class="separator:aecd12a18eeb0ee701fc7b0efd5068266"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a86419b4256b0bf5e099fa746cbcf8e8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a86419b4256b0bf5e099fa746cbcf8e8d">asteraSPISetup</a> (<a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a> product)</td></tr>
<tr class="memdesc:a86419b4256b0bf5e099fa746cbcf8e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level SPI Initialization and setup. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. This function has to be called before any other SPI function. Initialize and Open the SPI driver, setup the clocks, Pin signals, baud rate, and other SPI parameters.  <br /></td></tr>
<tr class="separator:a86419b4256b0bf5e099fa746cbcf8e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dca44511b92f3a219d53c4e9685d70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#ae7dca44511b92f3a219d53c4e9685d70">asteraSPIClose</a> (<a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a> product)</td></tr>
<tr class="memdesc:ae7dca44511b92f3a219d53c4e9685d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level SPI Initialization and setup. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. This function is called to close the SPI device.  <br /></td></tr>
<tr class="separator:ae7dca44511b92f3a219d53c4e9685d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1bcd1e189d052c6918f54dffa01059"><td class="memItemLeft" align="right" valign="top"><a id="aca1bcd1e189d052c6918f54dffa01059" name="aca1bcd1e189d052c6918f54dffa01059"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>asteraSPIReset</b> (<a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a> product)</td></tr>
<tr class="separator:aca1bcd1e189d052c6918f54dffa01059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3bb1a48505737c84aaf11bb2ec23ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#aaa3bb1a48505737c84aaf11bb2ec23ed">asteraSPIChipBulkErase</a> (<a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a> product)</td></tr>
<tr class="memdesc:aaa3bb1a48505737c84aaf11bb2ec23ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level SPI API to completely bulk erase the flash chip THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. This function erases the entire flash chip.  <br /></td></tr>
<tr class="separator:aaa3bb1a48505737c84aaf11bb2ec23ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca9f0deb9da8eae88efb1be873f4c6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a9ca9f0deb9da8eae88efb1be873f4c6b">asteraSPIBlockErase</a> (<a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a> product, uint32_t block_addr, uint32_t block_count)</td></tr>
<tr class="memdesc:a9ca9f0deb9da8eae88efb1be873f4c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level block erase SPI function. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. This function erases one or more blocks of memory specified by the address.  <br /></td></tr>
<tr class="separator:a9ca9f0deb9da8eae88efb1be873f4c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047259b839e2dafc169d995997311c1c"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a047259b839e2dafc169d995997311c1c">asteraSPIRead</a> (<a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a> product, uint32_t addr)</td></tr>
<tr class="memdesc:a047259b839e2dafc169d995997311c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level SPI Read. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. reads one byte from the SPI bus at the address specified.  <br /></td></tr>
<tr class="separator:a047259b839e2dafc169d995997311c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bd047aed25ead22942d189cbde06df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a38bd047aed25ead22942d189cbde06df">asteraSPIReadBlock</a> (<a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a> product, uint32_t addr, uint8_t *data, uint32_t len)</td></tr>
<tr class="memdesc:a38bd047aed25ead22942d189cbde06df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level SPI Read Block. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. reads a block of bytes into the given array from the SPI bus at the address specified.  <br /></td></tr>
<tr class="separator:a38bd047aed25ead22942d189cbde06df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e393dac017a7638b0762d5a9bdd7300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a8e393dac017a7638b0762d5a9bdd7300">asteraSPIReadPage</a> (<a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a> product, uint32_t addr, uint8_t *data, uint32_t len)</td></tr>
<tr class="memdesc:a8e393dac017a7638b0762d5a9bdd7300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level SPI Read Page. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. Reads the number of pages desired from SPI bus at the address specified.  <br /></td></tr>
<tr class="separator:a8e393dac017a7638b0762d5a9bdd7300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edff1078270d42f03e8a236fa39e18c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a7edff1078270d42f03e8a236fa39e18c">asteraSPIWrite</a> (<a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a> product, uint32_t addr, uint8_t *data, uint32_t len)</td></tr>
<tr class="memdesc:a7edff1078270d42f03e8a236fa39e18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level SPI Write. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. writes a sequence of bytes to the SPI bus at the address specified the flash cells are not autmatically erased, it is important to clear the flash cells by calling the erase function before writing to the flash.  <br /></td></tr>
<tr class="separator:a7edff1078270d42f03e8a236fa39e18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8ccdac75eb92fd6b347a5fc8418726"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a6f8ccdac75eb92fd6b347a5fc8418726">asteraSPIWriteBlock</a> (<a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a> product, uint32_t addr, uint8_t *data, uint32_t len)</td></tr>
<tr class="memdesc:a6f8ccdac75eb92fd6b347a5fc8418726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level SPI Write Block. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. writes a block of bytes to the SPI bus at the address specified.  <br /></td></tr>
<tr class="separator:a6f8ccdac75eb92fd6b347a5fc8418726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab791f034fc71dd22cd28bd7976e2d441"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#ab791f034fc71dd22cd28bd7976e2d441">asteraSPIWritePage</a> (<a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a> product, uint32_t addr, uint8_t *data, uint32_t len)</td></tr>
<tr class="memdesc:ab791f034fc71dd22cd28bd7976e2d441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level SPI Write Page. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. Writes the number of pages desired to the SPI bus at the address specified.  <br /></td></tr>
<tr class="separator:ab791f034fc71dd22cd28bd7976e2d441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af0705d1a24d00713885b205c5d6840"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a8af0705d1a24d00713885b205c5d6840">leoSpiInit</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver)</td></tr>
<tr class="memdesc:a8af0705d1a24d00713885b205c5d6840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level code to initialize the DW APB.  <br /></td></tr>
<tr class="separator:a8af0705d1a24d00713885b205c5d6840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5235ae236a0f3ddd6938092e548429d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a5235ae236a0f3ddd6938092e548429d6">dw_apb_ssi_SSIENR</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver, uint32_t enable)</td></tr>
<tr class="memdesc:a5235ae236a0f3ddd6938092e548429d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level code to enable/disable the DW APB SSI  <br /></td></tr>
<tr class="separator:a5235ae236a0f3ddd6938092e548429d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7b785d49d9ec872c4e155ef6fb38b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#abf7b785d49d9ec872c4e155ef6fb38b3">dw_apb_ssi_SER</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver, uint32_t enable)</td></tr>
<tr class="memdesc:abf7b785d49d9ec872c4e155ef6fb38b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level code to select/not select slave device by using the Slave Enable Register in DW APB SSI Valid only when DW APB SSI is configured as a master device.  <br /></td></tr>
<tr class="separator:abf7b785d49d9ec872c4e155ef6fb38b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9295236392c024299336aea54004513c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a9295236392c024299336aea54004513c">dw_apb_ssi_CTRLR0</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver, uint32_t CTRLR0_val)</td></tr>
<tr class="memdesc:a9295236392c024299336aea54004513c"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level code to control the serial data transfer Cannot write into this register while DW APB SSI is enabled Valid only when DW APB SSI is configured as a master device.  <br /></td></tr>
<tr class="separator:a9295236392c024299336aea54004513c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a312f0a56397e468f5c7dfecfafcdca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a9a312f0a56397e468f5c7dfecfafcdca">dw_apb_ssi_CTRLR1</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver, uint32_t CTRLR1_val)</td></tr>
<tr class="memdesc:a9a312f0a56397e468f5c7dfecfafcdca"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level code to control the end of serial data transfers when in Rx mode. Cannot write into this register while DW APB SSI is enabled Valid only when DW APB SSI is configured as a master device. The DW_apb_ssi continues to rx serial data until the number of data frames received is equal to this register value plus 1.  <br /></td></tr>
<tr class="separator:a9a312f0a56397e468f5c7dfecfafcdca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86be803c04c299a120984588c3f1687d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a86be803c04c299a120984588c3f1687d">dw_apb_ssi_RXFLR</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver, uint32_t *value)</td></tr>
<tr class="memdesc:a86be803c04c299a120984588c3f1687d"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level code to check Rx FIFO level register read the register to get the number of valid data entries in the Rx FIFO memory.  <br /></td></tr>
<tr class="separator:a86be803c04c299a120984588c3f1687d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc9617db34e6fad7f78da066eb4632b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#acdc9617db34e6fad7f78da066eb4632b">dw_apb_ssi_TXFLR</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver, uint32_t *value)</td></tr>
<tr class="memdesc:acdc9617db34e6fad7f78da066eb4632b"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level code to check Tx FIFO level register read the register to get the number of valid data entries in the Tx FIFO memory.  <br /></td></tr>
<tr class="separator:acdc9617db34e6fad7f78da066eb4632b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b960dbcbe8c5b4eb8c0be518cececef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a6b960dbcbe8c5b4eb8c0be518cececef">dw_apb_ssi_DRx_read</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver, uint32_t *value)</td></tr>
<tr class="memdesc:a6b960dbcbe8c5b4eb8c0be518cececef"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level code to read buffer from the transmit/receive FIFOs.  <br /></td></tr>
<tr class="separator:a6b960dbcbe8c5b4eb8c0be518cececef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a73f35ef3c22fd0f14bb16e8e89abcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a5a73f35ef3c22fd0f14bb16e8e89abcc">dw_apb_ssi_DRx_read_16_dw</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver, uint32_t *values)</td></tr>
<tr class="memdesc:a5a73f35ef3c22fd0f14bb16e8e89abcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level code to read (16b) buffer from the transmit/receive FIFOs.  <br /></td></tr>
<tr class="separator:a5a73f35ef3c22fd0f14bb16e8e89abcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccc2948494f122b9815f97d001cf2ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#aeccc2948494f122b9815f97d001cf2ae">dw_apb_ssi_DRx</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver, uint32_t DRx_val)</td></tr>
<tr class="memdesc:aeccc2948494f122b9815f97d001cf2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level code to write buffer to the transmit/receive FIFOs.  <br /></td></tr>
<tr class="separator:aeccc2948494f122b9815f97d001cf2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0108db36b4e43e32ba4330361093e0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#ab0108db36b4e43e32ba4330361093e0a">leo_spi_flash_write_block_protect</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver, int spi_device, uint8_t block_protect_en)</td></tr>
<tr class="memdesc:ab0108db36b4e43e32ba4330361093e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level code to enable/disable the flash write block protection  <br /></td></tr>
<tr class="separator:ab0108db36b4e43e32ba4330361093e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7a8520c7a8b9fcef07d658b01008e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a1f7a8520c7a8b9fcef07d658b01008e5">flash_read_sts_reg</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver, uint32_t *value)</td></tr>
<tr class="memdesc:a1f7a8520c7a8b9fcef07d658b01008e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level code to read flash status register  <br /></td></tr>
<tr class="separator:a1f7a8520c7a8b9fcef07d658b01008e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5647881f3f50ca5deb9fa445f48f789"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#ac5647881f3f50ca5deb9fa445f48f789">flash_check_write_in_prog</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver, uint32_t *value)</td></tr>
<tr class="memdesc:ac5647881f3f50ca5deb9fa445f48f789"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level code to check flash write in progress bit  <br /></td></tr>
<tr class="separator:ac5647881f3f50ca5deb9fa445f48f789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372af0fad59593b4c804444c3661bd14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a372af0fad59593b4c804444c3661bd14">flash_write_enable</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver)</td></tr>
<tr class="memdesc:a372af0fad59593b4c804444c3661bd14"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level code to enable flash write  <br /></td></tr>
<tr class="separator:a372af0fad59593b4c804444c3661bd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e77e453cf060aff1a88b078633365fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a1e77e453cf060aff1a88b078633365fd">flash_subsector_erase</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver, uint32_t addr, int spiDevice, int protect)</td></tr>
<tr class="memdesc:a1e77e453cf060aff1a88b078633365fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level code to erase flash subsectors (4KB)  <br /></td></tr>
<tr class="separator:a1e77e453cf060aff1a88b078633365fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b368c568fbe63b6cab149baa93622c"><td class="memItemLeft" align="right" valign="top"><a id="a08b368c568fbe63b6cab149baa93622c" name="a08b368c568fbe63b6cab149baa93622c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>flash_block_erase</b> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver, uint32_t addr, int spiDdevice, int protect)</td></tr>
<tr class="separator:a08b368c568fbe63b6cab149baa93622c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c44164a7ef3b87e7eaaaca1a6752725"><td class="memItemLeft" align="right" valign="top"><a id="a5c44164a7ef3b87e7eaaaca1a6752725" name="a5c44164a7ef3b87e7eaaaca1a6752725"></a>
<a class="el" href="leo__error_8h.html#a2f7909bc4b30a2692fc751e1d45dd1d1">LeoErrorType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>flash_erase_range</b> (<a class="el" href="leo__api__types_8h.html#ab3871e3352cab46331ebcfd4026dad31">LeoDeviceType</a> *leoDevice, uint32_t mem_min, uint32_t mem_max)</td></tr>
<tr class="separator:a5c44164a7ef3b87e7eaaaca1a6752725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b82f93337b1320d4e718a8133a2fe1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="leo__error_8h.html#a2f7909bc4b30a2692fc751e1d45dd1d1">LeoErrorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a89b82f93337b1320d4e718a8133a2fe1">flash_write</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver, uint32_t start_addr, size_t num_words_to_write, uint32_t *word_arr)</td></tr>
<tr class="memdesc:a89b82f93337b1320d4e718a8133a2fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level code to write words to flash  <br /></td></tr>
<tr class="separator:a89b82f93337b1320d4e718a8133a2fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e22bdaeec9afbd43bde4be967e546a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="leo__error_8h.html#a2f7909bc4b30a2692fc751e1d45dd1d1">LeoErrorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a4e22bdaeec9afbd43bde4be967e546a8">flash_read</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver, uint32_t start_addr, size_t num_words_to_read, uint32_t *values)</td></tr>
<tr class="memdesc:a4e22bdaeec9afbd43bde4be967e546a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level code to read words from flash  <br /></td></tr>
<tr class="separator:a4e22bdaeec9afbd43bde4be967e546a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555f6d11a9ce124e546ebb876b7d29bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a555f6d11a9ce124e546ebb876b7d29bf">leo_spi_flash_bulk_erase</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver)</td></tr>
<tr class="memdesc:a555f6d11a9ce124e546ebb876b7d29bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level code to erase entire flash chip. The Chip-Erase instruction clears all bits in the device to ‘F’ The Chip-Erase instruction is ignored if any of the memory area is protected. Prior to any write operation, it is required to execute the <a class="el" href="leo__spi_8h.html#a372af0fad59593b4c804444c3661bd14" title="low-level code to enable flash write">flash_write_enable()</a>.  <br /></td></tr>
<tr class="separator:a555f6d11a9ce124e546ebb876b7d29bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987e5a5d3d2d6a395058d764fa224886"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a987e5a5d3d2d6a395058d764fa224886">flash_read_jedec</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver, uint32_t *value)</td></tr>
<tr class="memdesc:a987e5a5d3d2d6a395058d764fa224886"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level code to read the unique JEDEC ID of the flash chip  <br /></td></tr>
<tr class="separator:a987e5a5d3d2d6a395058d764fa224886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f558eae796949ed9bd0005a722791fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#a7f558eae796949ed9bd0005a722791fa">read_fw_version</a> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver, uint32_t *values)</td></tr>
<tr class="memdesc:a7f558eae796949ed9bd0005a722791fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level code to read the unique version of the FW  <br /></td></tr>
<tr class="separator:a7f558eae796949ed9bd0005a722791fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bac07a3bc6fe9f3405dde69fded111"><td class="memItemLeft" align="right" valign="top"><a id="ad8bac07a3bc6fe9f3405dde69fded111" name="ad8bac07a3bc6fe9f3405dde69fded111"></a>
<a class="el" href="leo__error_8h.html#a2f7909bc4b30a2692fc751e1d45dd1d1">LeoErrorType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>flash_verify_block_crc</b> (<a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *leoDriver, uint32_t startAddr, size_t lenDWords, uint32_t crc)</td></tr>
<tr class="separator:ad8bac07a3bc6fe9f3405dde69fded111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec3a54ac19f3190c1885ea203635be8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="leo__error_8h.html#a2f7909bc4b30a2692fc751e1d45dd1d1">LeoErrorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="leo__spi_8h.html#acec3a54ac19f3190c1885ea203635be8">leo_spi_program_flash</a> (<a class="el" href="leo__api__types_8h.html#ab3871e3352cab46331ebcfd4026dad31">LeoDeviceType</a> *leoDevice, const char *filename)</td></tr>
<tr class="memdesc:acec3a54ac19f3190c1885ea203635be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">program Leo SPI with the new flash memory  <br /></td></tr>
<tr class="separator:acec3a54ac19f3190c1885ea203635be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8266ac22047a8799fc589217e577089b"><td class="memItemLeft" align="right" valign="top"><a id="a8266ac22047a8799fc589217e577089b" name="a8266ac22047a8799fc589217e577089b"></a>
<a class="el" href="leo__error_8h.html#a2f7909bc4b30a2692fc751e1d45dd1d1">LeoErrorType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>leo_spi_update_target</b> (<a class="el" href="leo__api__types_8h.html#ab3871e3352cab46331ebcfd4026dad31">LeoDeviceType</a> *device, char *filename, int target, int verify)</td></tr>
<tr class="separator:a8266ac22047a8799fc589217e577089b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2348486f5a15fc86ae72dcd4765003eb"><td class="memItemLeft" align="right" valign="top"><a id="a2348486f5a15fc86ae72dcd4765003eb" name="a2348486f5a15fc86ae72dcd4765003eb"></a>
<a class="el" href="leo__error_8h.html#a2f7909bc4b30a2692fc751e1d45dd1d1">LeoErrorType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>leo_spi_verify_crc</b> (<a class="el" href="leo__api__types_8h.html#ab3871e3352cab46331ebcfd4026dad31">LeoDeviceType</a> *device, char *filename)</td></tr>
<tr class="separator:a2348486f5a15fc86ae72dcd4765003eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cd7b2b9ee24c06ca23a0959cbf79db"><td class="memItemLeft" align="right" valign="top"><a id="a63cd7b2b9ee24c06ca23a0959cbf79db" name="a63cd7b2b9ee24c06ca23a0959cbf79db"></a>
<a class="el" href="leo__error_8h.html#a2f7909bc4b30a2692fc751e1d45dd1d1">LeoErrorType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>leoSpiCheckCompatibility</b> (<a class="el" href="leo__api__types_8h.html#ab3871e3352cab46331ebcfd4026dad31">LeoDeviceType</a> *device, uint8_t *fwBuf)</td></tr>
<tr class="separator:a63cd7b2b9ee24c06ca23a0959cbf79db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Definition of SPI types for the SDK. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9ca9f0deb9da8eae88efb1be873f4c6b" name="a9ca9f0deb9da8eae88efb1be873f4c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca9f0deb9da8eae88efb1be873f4c6b">&#9670;&#160;</a></span>asteraSPIBlockErase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asteraSPIBlockErase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a>&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low-level block erase SPI function. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. This function erases one or more blocks of memory specified by the address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_addr</td><td>: Address of the block to erase </td></tr>
    <tr><td class="paramname">block_count</td><td>: Number of blocks to erase </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa3bb1a48505737c84aaf11bb2ec23ed" name="aaa3bb1a48505737c84aaf11bb2ec23ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3bb1a48505737c84aaf11bb2ec23ed">&#9670;&#160;</a></span>asteraSPIChipBulkErase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asteraSPIChipBulkErase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a>&#160;</td>
          <td class="paramname"><em>product</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low-level SPI API to completely bulk erase the flash chip THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. This function erases the entire flash chip. </p>

</div>
</div>
<a id="ae7dca44511b92f3a219d53c4e9685d70" name="ae7dca44511b92f3a219d53c4e9685d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7dca44511b92f3a219d53c4e9685d70">&#9670;&#160;</a></span>asteraSPIClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asteraSPIClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a>&#160;</td>
          <td class="paramname"><em>product</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low-level SPI Initialization and setup. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. This function is called to close the SPI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ProductType</td><td>(Leo) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a047259b839e2dafc169d995997311c1c" name="a047259b839e2dafc169d995997311c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047259b839e2dafc169d995997311c1c">&#9670;&#160;</a></span>asteraSPIRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char asteraSPIRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a>&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low-level SPI Read. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. reads one byte from the SPI bus at the address specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>: Address of the byte to read from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38bd047aed25ead22942d189cbde06df" name="a38bd047aed25ead22942d189cbde06df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38bd047aed25ead22942d189cbde06df">&#9670;&#160;</a></span>asteraSPIReadBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asteraSPIReadBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a>&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low-level SPI Read Block. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. reads a block of bytes into the given array from the SPI bus at the address specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>: address to read from </td></tr>
    <tr><td class="paramname">data</td><td>: pointer to the array to store the data that was read </td></tr>
    <tr><td class="paramname">size</td><td>: number of bytes to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e393dac017a7638b0762d5a9bdd7300" name="a8e393dac017a7638b0762d5a9bdd7300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e393dac017a7638b0762d5a9bdd7300">&#9670;&#160;</a></span>asteraSPIReadPage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asteraSPIReadPage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a>&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low-level SPI Read Page. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. Reads the number of pages desired from SPI bus at the address specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>: Address of the byte to read from </td></tr>
    <tr><td class="paramname">data</td><td>: pointer to the array to store the data that was read </td></tr>
    <tr><td class="paramname">size</td><td>: number of bytes to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86419b4256b0bf5e099fa746cbcf8e8d" name="a86419b4256b0bf5e099fa746cbcf8e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86419b4256b0bf5e099fa746cbcf8e8d">&#9670;&#160;</a></span>asteraSPISetup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asteraSPISetup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a>&#160;</td>
          <td class="paramname"><em>product</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low-level SPI Initialization and setup. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. This function has to be called before any other SPI function. Initialize and Open the SPI driver, setup the clocks, Pin signals, baud rate, and other SPI parameters. </p>

</div>
</div>
<a id="a7edff1078270d42f03e8a236fa39e18c" name="a7edff1078270d42f03e8a236fa39e18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7edff1078270d42f03e8a236fa39e18c">&#9670;&#160;</a></span>asteraSPIWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asteraSPIWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a>&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low-level SPI Write. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. writes a sequence of bytes to the SPI bus at the address specified the flash cells are not autmatically erased, it is important to clear the flash cells by calling the erase function before writing to the flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>: The position in the flash to write the first byte </td></tr>
    <tr><td class="paramname">data</td><td>: The data to write to the flash </td></tr>
    <tr><td class="paramname">len</td><td>: The number of bytes to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f8ccdac75eb92fd6b347a5fc8418726" name="a6f8ccdac75eb92fd6b347a5fc8418726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8ccdac75eb92fd6b347a5fc8418726">&#9670;&#160;</a></span>asteraSPIWriteBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asteraSPIWriteBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a>&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low-level SPI Write Block. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. writes a block of bytes to the SPI bus at the address specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>: The position in the flash to write the first byte </td></tr>
    <tr><td class="paramname">data</td><td>: The data to write to the flash </td></tr>
    <tr><td class="paramname">len</td><td>: The number of bytes to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab791f034fc71dd22cd28bd7976e2d441" name="ab791f034fc71dd22cd28bd7976e2d441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab791f034fc71dd22cd28bd7976e2d441">&#9670;&#160;</a></span>asteraSPIWritePage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asteraSPIWritePage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__globals_8h.html#adea96f6482bfe75f7a5df44d48142691">AsteraProductType</a>&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low-level SPI Write Page. THIS FUNCTION MUST BE IMPLEMENTED IN THE USER'S APPLICATION. Writes the number of pages desired to the SPI bus at the address specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>: The position in the flash to write the first byte </td></tr>
    <tr><td class="paramname">data</td><td>: The data to write to the flash </td></tr>
    <tr><td class="paramname">len</td><td>: The number of bytes to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9295236392c024299336aea54004513c" name="a9295236392c024299336aea54004513c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9295236392c024299336aea54004513c">&#9670;&#160;</a></span>dw_apb_ssi_CTRLR0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dw_apb_ssi_CTRLR0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>CTRLR0_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level code to control the serial data transfer Cannot write into this register while DW APB SSI is enabled Valid only when DW APB SSI is configured as a master device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver </td></tr>
    <tr><td class="paramname">CTRLR0_val</td><td>SPI Frame format, Data &amp; Control Frame Size, transfer mode, Serial Clock Polarity, Serial Clock Phase. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a312f0a56397e468f5c7dfecfafcdca" name="a9a312f0a56397e468f5c7dfecfafcdca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a312f0a56397e468f5c7dfecfafcdca">&#9670;&#160;</a></span>dw_apb_ssi_CTRLR1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dw_apb_ssi_CTRLR1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>CTRLR1_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level code to control the end of serial data transfers when in Rx mode. Cannot write into this register while DW APB SSI is enabled Valid only when DW APB SSI is configured as a master device. The DW_apb_ssi continues to rx serial data until the number of data frames received is equal to this register value plus 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver </td></tr>
    <tr><td class="paramname">CTRLR1_val</td><td>Number of data frames in a transfer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeccc2948494f122b9815f97d001cf2ae" name="aeccc2948494f122b9815f97d001cf2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccc2948494f122b9815f97d001cf2ae">&#9670;&#160;</a></span>dw_apb_ssi_DRx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dw_apb_ssi_DRx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>DRx_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level code to write buffer to the transmit/receive FIFOs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver </td></tr>
    <tr><td class="paramname">value</td><td>value to write to the transmit/receive FIFOs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b960dbcbe8c5b4eb8c0be518cececef" name="a6b960dbcbe8c5b4eb8c0be518cececef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b960dbcbe8c5b4eb8c0be518cececef">&#9670;&#160;</a></span>dw_apb_ssi_DRx_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dw_apb_ssi_DRx_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level code to read buffer from the transmit/receive FIFOs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver </td></tr>
    <tr><td class="paramname">value</td><td>value read from the transmit/receive FIFOs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a73f35ef3c22fd0f14bb16e8e89abcc" name="a5a73f35ef3c22fd0f14bb16e8e89abcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a73f35ef3c22fd0f14bb16e8e89abcc">&#9670;&#160;</a></span>dw_apb_ssi_DRx_read_16_dw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dw_apb_ssi_DRx_read_16_dw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level code to read (16b) buffer from the transmit/receive FIFOs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver </td></tr>
    <tr><td class="paramname">value</td><td>value read (16b) from the transmit/receive FIFOs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86be803c04c299a120984588c3f1687d" name="a86be803c04c299a120984588c3f1687d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86be803c04c299a120984588c3f1687d">&#9670;&#160;</a></span>dw_apb_ssi_RXFLR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dw_apb_ssi_RXFLR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level code to check Rx FIFO level register read the register to get the number of valid data entries in the Rx FIFO memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver </td></tr>
    <tr><td class="paramname">value</td><td>number of valid data entries in the Rx FIFO memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf7b785d49d9ec872c4e155ef6fb38b3" name="abf7b785d49d9ec872c4e155ef6fb38b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7b785d49d9ec872c4e155ef6fb38b3">&#9670;&#160;</a></span>dw_apb_ssi_SER()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dw_apb_ssi_SER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level code to select/not select slave device by using the Slave Enable Register in DW APB SSI Valid only when DW APB SSI is configured as a master device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver </td></tr>
    <tr><td class="paramname">enable</td><td>1 means slave is selected, 0 means no slave is selected </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5235ae236a0f3ddd6938092e548429d6" name="a5235ae236a0f3ddd6938092e548429d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5235ae236a0f3ddd6938092e548429d6">&#9670;&#160;</a></span>dw_apb_ssi_SSIENR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dw_apb_ssi_SSIENR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level code to enable/disable the DW APB SSI </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver </td></tr>
    <tr><td class="paramname">enable</td><td>1 to enable, 0 to disable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdc9617db34e6fad7f78da066eb4632b" name="acdc9617db34e6fad7f78da066eb4632b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc9617db34e6fad7f78da066eb4632b">&#9670;&#160;</a></span>dw_apb_ssi_TXFLR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dw_apb_ssi_TXFLR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level code to check Tx FIFO level register read the register to get the number of valid data entries in the Tx FIFO memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver </td></tr>
    <tr><td class="paramname">value</td><td>number of valid data entries in the Transmit FIFO memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5647881f3f50ca5deb9fa445f48f789" name="ac5647881f3f50ca5deb9fa445f48f789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5647881f3f50ca5deb9fa445f48f789">&#9670;&#160;</a></span>flash_check_write_in_prog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flash_check_write_in_prog </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level code to check flash write in progress bit </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver </td></tr>
    <tr><td class="paramname">value</td><td>value determines if flash write is in progress </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e22bdaeec9afbd43bde4be967e546a8" name="a4e22bdaeec9afbd43bde4be967e546a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e22bdaeec9afbd43bde4be967e546a8">&#9670;&#160;</a></span>flash_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="leo__error_8h.html#a2f7909bc4b30a2692fc751e1d45dd1d1">LeoErrorType</a> flash_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>start_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_words_to_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level code to read words from flash </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver </td></tr>
    <tr><td class="paramname">start_addr</td><td>start address of the flash to be read </td></tr>
    <tr><td class="paramname">num_words</td><td>number of words to be read </td></tr>
    <tr><td class="paramname">word_arr</td><td>pointer to the data to be read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LeoErrorType </dd></dl>

</div>
</div>
<a id="a987e5a5d3d2d6a395058d764fa224886" name="a987e5a5d3d2d6a395058d764fa224886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987e5a5d3d2d6a395058d764fa224886">&#9670;&#160;</a></span>flash_read_jedec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flash_read_jedec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level code to read the unique JEDEC ID of the flash chip </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver </td></tr>
    <tr><td class="paramname">value</td><td>value read (JEDEC ID) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f7a8520c7a8b9fcef07d658b01008e5" name="a1f7a8520c7a8b9fcef07d658b01008e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7a8520c7a8b9fcef07d658b01008e5">&#9670;&#160;</a></span>flash_read_sts_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flash_read_sts_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level code to read flash status register </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver </td></tr>
    <tr><td class="paramname">value</td><td>value read from the flash status register </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e77e453cf060aff1a88b078633365fd" name="a1e77e453cf060aff1a88b078633365fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e77e453cf060aff1a88b078633365fd">&#9670;&#160;</a></span>flash_subsector_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flash_subsector_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spiDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>protect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level code to erase flash subsectors (4KB) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver </td></tr>
    <tr><td class="paramname">addr</td><td>address of the flash subsector to be erased </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89b82f93337b1320d4e718a8133a2fe1" name="a89b82f93337b1320d4e718a8133a2fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b82f93337b1320d4e718a8133a2fe1">&#9670;&#160;</a></span>flash_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="leo__error_8h.html#a2f7909bc4b30a2692fc751e1d45dd1d1">LeoErrorType</a> flash_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>start_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_words_to_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>word_arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level code to write words to flash </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver </td></tr>
    <tr><td class="paramname">start_addr</td><td>start address of the flash to be written </td></tr>
    <tr><td class="paramname">num_words</td><td>number of words to be written </td></tr>
    <tr><td class="paramname">word_arr</td><td>pointer to the data to be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LeoErrorType </dd></dl>

</div>
</div>
<a id="a372af0fad59593b4c804444c3661bd14" name="a372af0fad59593b4c804444c3661bd14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372af0fad59593b4c804444c3661bd14">&#9670;&#160;</a></span>flash_write_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flash_write_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level code to enable flash write </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a555f6d11a9ce124e546ebb876b7d29bf" name="a555f6d11a9ce124e546ebb876b7d29bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555f6d11a9ce124e546ebb876b7d29bf">&#9670;&#160;</a></span>leo_spi_flash_bulk_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void leo_spi_flash_bulk_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level code to erase entire flash chip. The Chip-Erase instruction clears all bits in the device to ‘F’ The Chip-Erase instruction is ignored if any of the memory area is protected. Prior to any write operation, it is required to execute the <a class="el" href="leo__spi_8h.html#a372af0fad59593b4c804444c3661bd14" title="low-level code to enable flash write">flash_write_enable()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0108db36b4e43e32ba4330361093e0a" name="ab0108db36b4e43e32ba4330361093e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0108db36b4e43e32ba4330361093e0a">&#9670;&#160;</a></span>leo_spi_flash_write_block_protect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void leo_spi_flash_write_block_protect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spi_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block_protect_en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level code to enable/disable the flash write block protection </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver </td></tr>
    <tr><td class="paramname">spi_device</td><td>type of spi device - some don't support write block protect command </td></tr>
    <tr><td class="paramname">value</td><td>1 to enable, 0 to disable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acec3a54ac19f3190c1885ea203635be8" name="acec3a54ac19f3190c1885ea203635be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec3a54ac19f3190c1885ea203635be8">&#9670;&#160;</a></span>leo_spi_program_flash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="leo__error_8h.html#a2f7909bc4b30a2692fc751e1d45dd1d1">LeoErrorType</a> leo_spi_program_flash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#ab3871e3352cab46331ebcfd4026dad31">LeoDeviceType</a> *&#160;</td>
          <td class="paramname"><em>leoDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>program Leo SPI with the new flash memory </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">leoDevice</td><td>pointer to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flashFileName</td><td>filepath name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">persistentDataBuf</td><td>data to be written into persistent data block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8af0705d1a24d00713885b205c5d6840" name="a8af0705d1a24d00713885b205c5d6840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af0705d1a24d00713885b205c5d6840">&#9670;&#160;</a></span>leoSpiInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void leoSpiInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low-level code to initialize the DW APB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver</td></tr>
  </table>
  </dd>
</dl>
<p>Low-level code to initialize the DW APB. </p>

</div>
</div>
<a id="a7f558eae796949ed9bd0005a722791fa" name="a7f558eae796949ed9bd0005a722791fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f558eae796949ed9bd0005a722791fa">&#9670;&#160;</a></span>read_fw_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_fw_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="leo__api__types_8h.html#a0e1807c16a7c4406767cc816f126d753">LeoI2CDriverType</a> *&#160;</td>
          <td class="paramname"><em>leoDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level code to read the unique version of the FW </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leoDriver</td><td>pointer to the Leo driver </td></tr>
    <tr><td class="paramname">value</td><td>value read (FW version) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d42a07b2115f6ca15f9c9983df0e71e7.html">leo-sdk-c</a></li><li class="navelem"><a class="el" href="dir_6bfd95c2b288859999b069e676501644.html">include</a></li><li class="navelem"><a class="el" href="leo__spi_8h.html">leo_spi.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
